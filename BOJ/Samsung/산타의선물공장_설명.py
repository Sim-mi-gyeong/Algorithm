# 벨트마다 belt[i] := i 번 벨트에서 가장 앞에 있는 박스 번호를 기록 -> 없다면 -1 (인덱스가 1 이상이니까, 없다면 0도 가능)

# push_box 함수 : i번 특정 벨트에 i번 특정 상자를 추가하는 행위


# input 의 push 함수
# 입력이 잘 받아졌는지 확인을 위해 input 뒤에 실행해보기
def push_box(belt_idx, box[belt_idx]):
    pass
    # 벨트마다 front, back 을 알아야 함 

    # 만약 이 벨트가 비었었다면, (만약 비어있는 벨트였다면) -> 벨트의 처음과 끝에 상자를 넣어주기
    # -> 이 상자는 벨트의 유일한 상자이므로 -> 박스의 prev, next 를 아무 상자도 없도록

    # 만약 비어있지 않았다면, 상자를 추가할 때 2개의 연결 추가 필요
    # 가장 마지막에 있던 상자와 - 새로운 상자 간의 connection (2개의 연결)
    # - 새로 들어온 상자의 이전에는, 기존에 들어있던 마지막 상자의 end 를 가리키도록
    # - 기존에 있던 상자의 다음에는 새로 들어온 상자의 prev 를 가리키도록
    # - 벨트의 마지막 상자를, 새로 들어온 상자로 


def input():
    q = int(input())
    push_box(i, box[j])

def drop_belt(i):
    pass
def query_200():
    # 벨트를 하나씩 보면서 -> 벨트의 가장 앞쪽에 있는 상자가 조건을 만족하는 경우 -> 하차

    # 1. 만약, 비어있는 벨트라면 무시하기 -> Linked List 는 Null 체크를 계속해서 해야 함!

    # 2. 만약, 입력받은 무게보다 가벼우면 -> 그 상자를 하차 -> sum 에 누적 
    # -> 하차를 하니 없애준다
    # 하차 하기
    drop_belt(i)
    # 가장 앞에 있는 상자를 찾았고 -> 그 벨트의 가장 앞에 있는 상자는 그 상자의 다음 상자로 바꿔주기!
    ### 상자의 벨트 번호를 0 으로 -> 하차가 되는 것이라는 의미
    ### box_map.erase(box -> idx)   # 박스의 인덱스에 해당하는 맵에서 박스의 정보 삭제 -> 300 은 쉽게 구현 가능
    # 이 상자는, 자신의 앞에 아무것도 없어야 하니까 -> 하차할 상자의 prev 를 Null 로
    # 단, 이때 이것은 다음 상자가 존재할 때만 일어나야 한다.
    # + 빠진 상자의 다음 next 링크도 끊어주기 

    # 3. 그게 아니라면, 벨트의 가장 뒤로 옮기기
    # - 일단 벨트에서 하차를 하고 -> 하차된 상자를 다시 벨트에 넣어주기 -> 가장 뒤로 넣는 것이 구현 가능
    drop_belt(i)
    push_box(i, box)

    
    pass

# drop_box 에서 하차를 할 때, 하차가 되었는지 판단하는 부분이 필요
# 상자의 벨트 번호가 0번이라는 것은, 이미 하차가 된 것 
def query_300():
    # 1. 만약에, box_map 에서 id 를 찾았는데, 존재하지 않는 친구라면 -> 리턴 -1 

    # 2. 그게 아니라면, 벨트에서 제거
    # box 를 pop 했으니 -> prev 와 next 잘 연결

    ### 2-1. 만약, 내가 제거한 상자가 벨트의 가장 앞이라면, 가장 뒤라면 ? -> 벨트 하나가 통째로 비어버리는 상황
    # if (prev == NULL and next == Null) {
    #     erase_box(id)    
    #     belt[b].front = blet[b].end = NULL
    # }

    ### 2-2. next 는 있는데 prev 가 없으면 -> 벨트의 가장 앞 상자가 바뀌는 상황
    # 벨트의 가장 앞을 다음으로 바꾸어주는 동시에 + 가장 앞 상자는 앞에 아무것도 없도록 처리헤주어야 함

    ### 2-3. 벨트의 가장 마지막 상자가 바뀌는 상황

    pass

def query_400():
    # 처음 상태
    # 1번의 prev 와 5번의 next 가 없었고, 
    # 내가 당기려는 상자의 앞과 나 사이에서는 서로 prev 와 next 를 연결했었고
    # 가장 마지막 상자는 다음이 없었는데

    # 당긴 경우, 
    # 내가 당긴 상자는 prev 가 Null 이 되어야 하고, 내 앞에 있던 상자는 next 가 Null 이 되어야 하고 
    # 1번과 5번의 prev 와 next 는 서로를 가리켜야 함

    # 존재하는지 안 하는지 알아야 함

    # 1. 벨트 하나가 통째로 비어버리는 상황 - 원래 하나밖에 없던 게 유일했던 상황이라면
    # 아무것도 할 필요 없음

    # 2. 가장 앞 상자를 찾은 경우 -> 아무것도 할 필요 없음

    # 3. 가장 뒷 상자를 빼오는 경우
    # (확인하는) 현재 상자의 prev 와 next 가 바뀌어야 함
    # - 현재 상자의 다음은, 원래 가장 앞에 있던 상자의 앞 / 현재 상자의 앞은, Null

    # (확인하는) 현재 상자의 앞에 있던 상자는 다음이 없어지고 / 그 앞에 내가 온다
    
    # 4. 가운데에 있는 상자를 빼오는 경우 


    # 리턴은, 벨트를 돌려주면 됨
    pass

def query_500():
    ### 벨트마다 망가졌는지, 아닌지를 저장하고 있어야 함
    # 0. 벨트가 broken 이라면 -> 리턴 -1 

    # 1. 삭제한 벨트가 이미 비어있는 경우 -> 무시(아무 일도 안 해도 됨)

    # 2. 0과 1이 아니라면 모든 경우에 대해 처리 - 망가진 벨트가 어디 뒤로(어느 벨트 뒤에 붙는지) 가는지 확인 -> target

    # 2-1. 벨트 B 에서 가장 앞에 있던 상자가 -> 벨트 A 에서 가장 뒤에 있던 상자끼리 연결

    # 2-2. B 에 있던 상자들이 A 벨트로 이동하는 것이므로, belt 멤버 변수를 A 로 바꿔주어야 함

    # 2-3. A벨트.end 를 B벨트.end 로 바꾸어 주어야 함


    # 1) belt[b].front 와 belt[target].end 사이에 link 생성
    # 2) belt[b] 의 상자들의 belt 값을 target 으로 변경
    # 3) belt[target] 의 end 를 belt[b].end 로 변경

    # 상자가 10개까지고, 40만 연산 정도로 까지 가능

    pass


def pro():
    global q
    for _ in range(1, q):
        cal, idx = map(int, input().split())
        # cal == 100 -> # 공장 설립
        if cal == 200:
            # 물건 하차
            # 입력만 받고 -> 함수 인자로 빼내기
            sum = 0   # 하차되는 상자들의 무 총 합 / w = 10억 : 10개 빠면 최대 10억
            # 벨트를 하나씩 보면서 -> 벨트의 가장 앞쪽에 있는 상자가 조건을 만족하는 경우 -> 하차

            # 만약, 비어있는 벨트라면 무시하기 -> Linked List 는 Null 체크를 계속해서 해야 함!

            # 만약, 입력받은 무게보다 가벼우면 -> 그 상자를 하차 -> sum 에 누적 
            pass
        elif cal == 300:
            # 물건 제거
            pass
        elif cal == 400:
            # 물건 확인
            pass
        elif cal == 500:
            # 벨트 고장
            pass


# 200번은 시간 복잡도 O(M)   # 모든 벨트를 한 번씩 보면서 -> 각 벨트를 하차하냐, 싣냐 함수를 호출하는데, drop_box과 push_box 가 모두 O(1)
# 300번은 반복문 X -> O(1)
# 400번은 O(1)
# 500번은 어떤 벨트 안에 있는 모든 상자들의 벨트값을 변경하는 작업을 때문에 O(N)
# - 단, 최대 9번 호출되기 때문에, 시간 초과의 요인이 되지 않음을 알 수 있다 !