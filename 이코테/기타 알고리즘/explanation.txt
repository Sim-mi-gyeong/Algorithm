1. 소수(Prime Number)
 1) 소수의 개념
  - 소수란, 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수
   Ex) 6은 1, 2, 3, 6으로 나누어 떨어짐 -> 소수 x
   Ex) 7은 1, 7을 제외하고는 나누어 떨어지지 X -> 소수
 2) 코딩 테스트에서, 어떠한 자연수가 소수인지 아닌지 판별해야 하는 문제 자주 출제

 3) 소수의 판별 - 기본적인 알고리즘 성능 분석
  - 2부터 X-1 까지의 모든 자연수에 대해 연산 수행
  -> 모든 수를 하나씩 확인한다는 점에서, 시간 복잡도 = O(X) -> 선형적으로 비례


2. 약수의 성질
 1) 모든 약수가 가운데 약수를 기준으로, 곱셈 연산에 대해 대칭을 이룸
  Ex) 16의 약수 : 1, 2, 4, 8, 16
   -> 이때, 2 X 8 = 16은 8 X 2 = 16과 대칭
 2) 따라서, 특정한 자연수의 모든 약수를 찾을 때 '가운데 약수(제곱근)까지만 확인'하면 된다.
  Ex) 16이 2로 나누어 떨어진다는 것은 -> 8로도 나누어 떨어진다는 것을 의미
 3) 이 성질을 이용해 소수 판별 알고리즘 개선 가능
 4) 소수의 판별 - 개선된 알고리즘 성능 분석
  - 2부터 X의 제곱근(소수점 이하 무시)까지의 모든 자연수에 대해 연산 수행
  -> 시간 복잡도 = O(N^1/2)


3. 다수의 소수 판별 - 에라토스테네스 체 알고리즘
 - 하나의 수에 대해 소수인지/아닌지를 판별하는 방법이 아닌, 
 - 특정한 수의 범위 안에 존재하는 '모든 소수'를 찾아야 할 때 -> '에라토스테네스 체 알고리즘' 사용 가능

 (1) 개념
  - 다수의 자연수에 대해 소수 여부를 판별할 때 사용되는 대표적인 알고리즘
  - 에라토스테네스 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용 가능

 (2) 에라토스테네스 체 알고리즘의 동작 과정
  1) 2부터 N 까지의 모든 자연수 나열
  2) 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다
  3) 남은 수 중에서 i의 배수를 모두 제거(i는 제거하지 않는다)
  4) 더 이상 반복할 수 없을 때까지 2번과 3번의 과정 반복

 (3) 에라토스테네스 체 알고리즘 성능 분석
  1) 에라토스테네스 체 알고리즘의 시간 복잡도는, 사실상 선형 시간에 가까울 정도로 매우 빠름
   - 시간 복잡도 = O(NlogN)
  2) 에라토스테네스 체 알고리즘은, 다수의 소수를 찾아야 하는 문제에서 효과적으로 사용 가능
   - 하지만, 각 자연수에 대한 소수 판별 여부를 저장해야 하므로 '메모리가 많이 필요'
   -> 10억이 소수인지/아닌지를 판별해야 할 때 에라토스테네스 체를 사용할 수 있는가?


4. 투 포인터(Tow Pointer) 
 (1) 투 포인터 알고리즘 개념(정의)
  - 투 포인터 알고리즘은, '리스트에 순차적으로 접근해야 할 때 -> 두 개의 점의 위치를 기록하면서 처리' 하는 알고리즘
  Ex) 흔히, 2, 3, 4, 5, 6, 7번 학생을 지목해야 할 때 -> 간단히 2번부터 7번까지의 학생이라고 부름
  - 리스트에 담긴 데이터에 순차적으로 접근해야 할 때는 -> '시작점과 끝점' 2개의 점으로 접근할 데이터의 범위 표현 가능

5. 특정한 합을 가지는 부분 연속 수열 찾기
 (1) 문제 설명
 - N 개의 자연수로 구성된 수열
 - 합이 M 인 부분 연속 수열의 개수는 ?
 - 수행 시간 제한은 O(N)

 (2) 문제 해결 아이디어
  - 투 포인터를 활용해 다음과 같은 알고리즘으로 문제 해결 가능
  1) 시작점(start)과 끝점(end)이 첫 번째 원소의 인덱스(0)를 가리키도록 한다.
  2) 현재 부분 합이 M과 같아면 -> 카운트
  3) 현재 부분 합이 M보다 작다면 -> end를 1 증가 -> 현재의 부분 합 증가
  4) 현재 부분 합이 M보다 크거나 같아면, start 1 증가 -> 현재의 부분 합 감소
  5) 모든 경우를 확인할 때까지, 2번부터 4번까지의 과정 반복

 (3) 동작 과정 
  - M = 5
  [초기 단계] 시작점과 끝점이 첫 번째 원소의 인덱스를 가리키도록 한다.
   - 현재의 부분합이 1이므로 무시
   - 현재 카운트 : 0
  [Step 1] 이전 단계에서의 부분합이 1이었기 때문에 -> end를 1 증가
   - 현재의 부분합은 3이므로 무시
   - 현재 카운트 : 0
  [Step 2] 이전 단계에서의 부분합 = 3 -> end를 1 증가
   - 현재의 부분합 = 6이므로 무시
   - 현재 카운트 : 0
  [Step 3] 이전 단계에서의 부분합 = 6 -> start를 1 증가  
   - 현재의 부분합 = 5 -> 카운트 증가
   - 현재 카운트 : 1
  [Step 4]  이전 단계에서의 부분합 = 5 -> start를 1 증가  
   - 현재의 부분합 = 3 
   - 현재 카운트 : 1
  [Step 5]  이전 단계에서의 부분합 = 3 -> end 1 증가  
   - 현재의 부분합 = 5 -> 카운트 증가
   - 현재 카운트 : 2
  [Step 6]  이전 단계에서의 부분합 = 5 -> start 1 증가  
   - 현재의 부분합 = 2
   - 현재 카운트 : 2   
  [Step 7]  이전 단계에서의 부분합 = 2 -> end 1 증가  
   - 현재의 부분합 = 7
   - 현재 카운트 : 2   
  [Step 6]  이전 단계에서의 부분합 = 7 -> start 1 증가  
   - 현재의 부분합 = 5 -> 카운트 증가
   - 현재 카운트 : 3   


6. 구간 합(Interval Sum)
 (1) 구간 합 문제
  - 연속적으로 나열된 N개의 수가 있을 때, 특정 구간의 모든 수를 합한 값을 계산하는 문제
  Ex) 5개의 데이터로 구성된 수열 {10, 20, 30, 40, 50} 이 있을 때
   - 두 번째 수 ~ 네 번째 수까지의 합 : 20 + 30 + 40 = 90

 (2) 구간 합 빠르게 계산하기 - 문제 설명
  1) N 개의 정수로 구성된 수열 존재
  2) M 개의 쿼리(Query) 정보가 주어짐
   - 각 쿼리는 Left와 Right 로 구성됨
   - 각 쿼리에 대해, [Left, Right] 구간에 포함된 데이터들의 합을 출력
  3) 수행 시간 제한은 O(N + M)

 (3) 구간 합 빠르게 계산하기 - 문제 해결 아이디어
  1) 접두사 합(Prefix Sum)
   - 배열의 맨 앞부터 ~ 특정 위치까지의 합을 미리 구해 놓은 것
  2) 접두사 합을 활용한 알고리즘
   - N 개의 수 위치 각각에 대해 접두사 합을 계산하여 P에 저장
   - 매 M개의 쿼리 정보를 확인할 때 구간 합은 P[Right] - P[Left - 1]