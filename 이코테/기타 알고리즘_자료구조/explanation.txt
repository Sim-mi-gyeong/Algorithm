1. 소수(Prime Number)
 1) 소수의 개념
  - 소수란, 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수
   Ex) 6은 1, 2, 3, 6으로 나누어 떨어짐 -> 소수 x
   Ex) 7은 1, 7을 제외하고는 나누어 떨어지지 X -> 소수
 2) 코딩 테스트에서, 어떠한 자연수가 소수인지 아닌지 판별해야 하는 문제 자주 출제

 3) 소수의 판별 - 기본적인 알고리즘 성능 분석
  - 2부터 X-1 까지의 모든 자연수에 대해 연산 수행
  -> 모든 수를 하나씩 확인한다는 점에서, 시간 복잡도 = O(X) -> 선형적으로 비례


2. 약수의 성질
 1) 모든 약수가 가운데 약수를 기준으로, 곱셈 연산에 대해 대칭을 이룸
  Ex) 16의 약수 : 1, 2, 4, 8, 16
   -> 이때, 2 X 8 = 16은 8 X 2 = 16과 대칭
 2) 따라서, 특정한 자연수의 모든 약수를 찾을 때 '가운데 약수(제곱근)까지만 확인'하면 된다.
  Ex) 16이 2로 나누어 떨어진다는 것은 -> 8로도 나누어 떨어진다는 것을 의미
 3) 이 성질을 이용해 소수 판별 알고리즘 개선 가능
 4) 소수의 판별 - 개선된 알고리즘 성능 분석
  - 2부터 X의 제곱근(소수점 이하 무시)까지의 모든 자연수에 대해 연산 수행
  -> 시간 복잡도 = O(N^1/2)


3. 다수의 소수 판별 - 에라토스테네스 체 알고리즘
 - 하나의 수에 대해 소수인지/아닌지를 판별하는 방법이 아닌, 
 - 특정한 수의 범위 안에 존재하는 '모든 소수'를 찾아야 할 때 -> '에라토스테네스 체 알고리즘' 사용 가능

 (1) 개념
  - 다수의 자연수에 대해 소수 여부를 판별할 때 사용되는 대표적인 알고리즘
  - 에라토스테네스 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용 가능

 (2) 에라토스테네스 체 알고리즘의 동작 과정
  1) 2부터 N 까지의 모든 자연수 나열
  2) 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다
  3) 남은 수 중에서 i의 배수를 모두 제거(i는 제거하지 않는다)
  4) 더 이상 반복할 수 없을 때까지 2번과 3번의 과정 반복

 (3) 에라토스테네스 체 알고리즘 성능 분석
  1) 에라토스테네스 체 알고리즘의 시간 복잡도는, 사실상 선형 시간에 가까울 정도로 매우 빠름
   - 시간 복잡도 = O(NlogN)
  2) 에라토스테네스 체 알고리즘은, 다수의 소수를 찾아야 하는 문제에서 효과적으로 사용 가능
   - 하지만, 각 자연수에 대한 소수 판별 여부를 저장해야 하므로 '메모리가 많이 필요'
   -> 10억이 소수인지/아닌지를 판별해야 할 때 에라토스테네스 체를 사용할 수 있는가?


4. 투 포인터(Tow Pointer) 
 (1) 투 포인터 알고리즘 개념(정의)
  - 투 포인터 알고리즘은, '리스트에 순차적으로 접근해야 할 때 -> 두 개의 점의 위치를 기록하면서 처리' 하는 알고리즘
  Ex) 흔히, 2, 3, 4, 5, 6, 7번 학생을 지목해야 할 때 -> 간단히 2번부터 7번까지의 학생이라고 부름
  - 리스트에 담긴 데이터에 순차적으로 접근해야 할 때는 -> '시작점과 끝점' 2개의 점으로 접근할 데이터의 범위 표현 가능

5. 특정한 합을 가지는 부분 연속 수열 찾기
 (1) 문제 설명
 - N 개의 자연수로 구성된 수열
 - 합이 M 인 부분 연속 수열의 개수는 ?
 - 수행 시간 제한은 O(N)

 (2) 문제 해결 아이디어
  - 투 포인터를 활용해 다음과 같은 알고리즘으로 문제 해결 가능
  1) 시작점(start)과 끝점(end)이 첫 번째 원소의 인덱스(0)를 가리키도록 한다.
  2) 현재 부분 합이 M과 같다면 -> 카운트
  3) 현재 부분 합이 M보다 작다면 -> end를 1 증가 -> 현재의 부분 합 증가
  4) 현재 부분 합이 M보다 크거나 같다면, start 1 증가 -> 현재의 부분 합 감소
  5) 모든 경우를 확인할 때까지, 2번부터 4번까지의 과정 반복

 (3) 동작 과정 
  - M = 5
  [초기 단계] 시작점과 끝점이 첫 번째 원소의 인덱스를 가리키도록 한다.
   - 현재의 부분합이 1이므로 무시
   - 현재 카운트 : 0
  [Step 1] 이전 단계에서의 부분합이 1이었기 때문에 -> end를 1 증가
   - 현재의 부분합은 3이므로 무시
   - 현재 카운트 : 0
  [Step 2] 이전 단계에서의 부분합 = 3 -> end를 1 증가
   - 현재의 부분합 = 6이므로 무시
   - 현재 카운트 : 0
  [Step 3] 이전 단계에서의 부분합 = 6 -> start를 1 증가  
   - 현재의 부분합 = 5 -> 카운트 증가
   - 현재 카운트 : 1
  [Step 4]  이전 단계에서의 부분합 = 5 -> start를 1 증가  
   - 현재의 부분합 = 3 
   - 현재 카운트 : 1
  [Step 5]  이전 단계에서의 부분합 = 3 -> end 1 증가  
   - 현재의 부분합 = 5 -> 카운트 증가
   - 현재 카운트 : 2
  [Step 6]  이전 단계에서의 부분합 = 5 -> start 1 증가  
   - 현재의 부분합 = 2
   - 현재 카운트 : 2   
  [Step 7]  이전 단계에서의 부분합 = 2 -> end 1 증가  
   - 현재의 부분합 = 7
   - 현재 카운트 : 2   
  [Step 6]  이전 단계에서의 부분합 = 7 -> start 1 증가  
   - 현재의 부분합 = 5 -> 카운트 증가
   - 현재 카운트 : 3   


6. 구간 합(Interval Sum)
 (1) 구간 합 문제
  - 연속적으로 나열된 N개의 수가 있을 때, 특정 구간의 모든 수를 합한 값을 계산하는 문제
  Ex) 5개의 데이터로 구성된 수열 {10, 20, 30, 40, 50} 이 있을 때
   - 두 번째 수 ~ 네 번째 수까지의 합 : 20 + 30 + 40 = 90

 (2) 구간 합 빠르게 계산하기 - 문제 설명
  1) N 개의 정수로 구성된 수열 존재
  2) M 개의 쿼리(Query) 정보가 주어짐
   - 각 쿼리는 Left와 Right 로 구성됨
   - 각 쿼리에 대해, [Left, Right] 구간에 포함된 데이터들의 합을 출력
  3) 수행 시간 제한은 O(N + M)

 (3) 구간 합 빠르게 계산하기 - 문제 해결 아이디어
  1) 접두사 합(Prefix Sum)
   - 배열의 맨 앞부터 ~ 특정 위치까지의 합을 미리 구해 놓은 것
  2) 접두사 합을 활용한 알고리즘
   - N 개의 수 위치 각각에 대해 접두사 합을 계산하여 P에 저장
   - 매 M개의 쿼리 정보를 확인할 때 구간 합은 P[Right] - P[Left - 1]


7. 우선순위 큐(Priority Queue)
 (1) 정의
  - 우선순위 큐는, '우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조'
  - 데이터를 우선순위에 따라 처리하고 싶을 때 사용
  Ex) 물건 데이터를 자료구조에 넣었다가 -> 가치가 높은 물건부터 꺼내서 확인해야 하는 경우

 (2) 자료구조에 따른 추출되는 데이터
  1) 스택(Stack) - 가장 나중에 삽입된 데이터
  2) 큐(Queue) - 가장 먼저 삽입된 데이터
  3) 우선순위 큐(Priority Queue) - 가장 우선순위가 높은 데이터

 (3) 우선순위 큐의 구현 방법
  1) 단순히 리스트를 이용한 구현
  2) 힙(Heap)을 이용한 구현

 (4) 데이터의 개수가 N개일 때, 구현 방식에 따른 시간 복잡도는,
    
    우선순위 큐 구현 방식      삽입 시간      삭제 시간
        리스트               O(1)         O(N)
       힙(Heap)           O(logN)       O(logN)
  
  - 리스트의 경우, 삭제할 데이터를 탐색(가장 우선순위가 높은 데이터 찾기)해야 하므로 선형적인 탐색 시간 필요
  - 힙은, 최악의 경우에도 O(logN)

 (5)단순히 N개의 데이터를 힙에 넣었다가 -> 모두 꺼내는 작업 = 정렬과 동일(힙 정렬)
   -> 이 경우, 시간 복잡도는 O(NlogN) (병합 정렬도 같은 시간 복잡도)


8. 힙(Heap)의 특징
 (1) 힙 자료구조 정의
  - 힙은, '완전 이진 트리 자료구조'의 일종
  - 힙에서는 항상 '루트 노드(root node)'를 제거
  1) 최소 힙(min heap)
   - 루트 노드가 가장 작은 값을 가진다.
   - 따라서, 값이 작은 데이터가 우선적으로 제거됨
  2) 최대 힙(max heap)
   - 루트 노드가 가장 큰 값을 가진다.
   - 따라서, 값이 큰 데이터가 우선적으로 제거됨

 (2) 완전 이진 트리(Complete Binary Tree)
  - 완전 이진 트리란, 루트(root) 노드부터 시작하여 -> 왼쪽 자식 노드, 오른쪽 자식 노드 순서대로
    데이터가 차례대로 삽입되는 트리(tree)


9. 힙 연산
 (1) 최소 힙 구성 함수 : Min-Heapify()
  1) 개념
   - (상향식) 부모 노드로 거슬러 올라가며 -> 부모보다 > 자신의 값이 더 작은 경우 -> 위치 교체
  2) 힙에 새로운 원소가 삽입될 때
   - 새로운 원소가 삽입되었을 때 -> O(logN)의 시간 복잡도로 힙 성질 유지 가능
  3) 힙에서 원소가 제거될 때
   - 원소가 제거되었을 때 -> O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있음
   - 원소를 제거할 때는, 가장 마지막 노드가 루트 노드의 위치로 오도록
   -> 이후에 '루트 노드에서부터 하향식으로(더 작은 자식 노드로)' Heapify()를 진행


10. 트리(Tree) 자료구조
 (1) 개념
  - 트리는, 가계도와 같은 '계층적인 구조'를 표현할 때 사용 가능한 자료구조
 (2) 트리 관련 용어
  - 루트 노드(root node) : 부모가 없는 최상위 노드
  - 단말 노드(leaf node) : 자식이 없는 노드
  - 크기(size) : 트리에 포함된 모든 노드의 개수
  - 깊이(depth) : 루트 노드부터의 거리
  - 높이(height) : 깊이 중 최댓값
  - 차수(degree) : 각 노드의 (자식 방향) 간선 개수
   -> 기본적으로, 트리의 크기가 N일때 -> 전체 간선의 개수는 N-1 개


11. 이진 탐색 트리(Binary Search Tree) - 탐색의 시간 복잡도 : O(logN)는 이진 탐색 트리가 이미 구성되어 있을 떄 !
 (1) 개념
  1) 이진 탐색이 동작할 수 있도록 고안된, 효율적인 탐색이 가능한 자료구조의 일종
  2) 이진 탐색 트리의 특징 : 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
   - 부모 노드보다 > 왼쪽 자식 노드가 작음
   - 부모 노드보다 < 오른쪽 자식 노드가 큼

 (2) 이진 탐색 트리에서 데이터 조회 과정
  - 이진 탐색 트리가 이미 구성되어 있다고 가정하고, 데이터를 조회하는 과정
  - 찾고자 하는 원소 : 37
  [Step 1] 루트 노드부터 방문하여 탐색 진행
   - 현재 노드(30)와 찾는 원소(37)를 비교
   - 찾는 원소가 더 크므로 -> 오른쪽 방문(탐색 범위가 절반으로 줄어듬)
   -> 탐색 범위가 절반으로 줄어듬
  [Step 2] 현재 노드와 값을 비교
   - 현재 노드(48)와 찾는 원소(37)를 비교
   - 찾는 원소가 더 작으므로 -> 왼쪽 방문
  [Step 3] 현재 노드와 값을 비교
   - 현재 노드(37)와 찾는 원소(37)을 비교
   - 원소를 찾았으므로 -> 탐색 종료


12. 트리의 순회(Tree Traversal)
 (1) 개념
  - 트리 자료구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하는 방법
  - 트리의 정보를 시각적으로 확인 가능
 (2) 트리 순회 방법 종류
  1) 전위 순회(pre-oreder traversal) : 루트를 먼저 방문
  2) 중위 순회(in-order traversal) : 왼쪽 자식을 방문한 뒤에 -> 루트 방문
  3) 후위 순회(post-order traversal) : 왼쪽 자식을 먼저 방문하고 -> 오른쪽 자식을 방문한 뒤에 -> 루트 방문
   - 후위 순회는, 왼쪽을 방문하고 -> (자기 자신으로 올라와) -> 오른쪽을 방문하고 -> 자기 자신을 방문

 (3) 트리 순회 예시
  Ex) 입력 예시
      7
      A B C
      B D E
      C F G
      D None None
      E None None
      F None None
      G None None
  1) 전위 순회 : A -> B -> D -> E -> C -> F -> G
  2) 중위 순회 : D -> B -> E -> A -> F -> C -> G
  3) 후위 순회 : D -> E -> B -> F -> G -> C -> A


13. 바이너리 인덱스 트리(Binary Indexed Tree, BIT, 펜윅 트리)
 - 데이터 업데이트가 가능한 상황에서의 구간 합(Interval Sum) 문제 -> 데이터 변경 + 구간 합 여러 번
 (1) 개념
  1) 정의
  - 2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해결해 줄 수 있는 자료구조
  - 펜윅 트리(fenwick tree) 라고도 함
  2) 정수에 따른 2진수 표기
  Ex1) 7 = 0000111
  Ex2) -7 = 1111001 (정수 7의 2진부 표기법에서 모든 비트에 대해 Flip -> 1을 더한 값)
  3) 0이 아닌 마지막 비트를 찾는 방법
  - 특정한 숫자 K의 0이 아닌 마지막 비트를 찾기 위해서, K & -K 를 계산하면 됨
  Ex1) 7은, 0이 아닌 가장 마지막 비트가 1 -> 1 출력

(2) 바이너리 인덱스 트리 생성 과정
 1) 트리 구조 만들기
 - 0이 아닌 마지막 비트 = 내가 저장하고 있는 값들의 개수 = 해당 인덱스가 담고 있는 값들의 개수
  Ex1) 16 = 0이 아닌 마지막 비트 값 = 16 -> 인덱스가 1 ~ 16 까지인 모든 데이터의 합을 담고 있음
  Ex2) 8 = 0이 아닌 마지막 비트 값 = 8 -> 인덱스가 1 ~ 8 까지인 모든 데이터의 합을 담고 있음
  Ex3) 7 = 0이 아닌 바미막 비트 값 = 1 -> 인덱스가 7인 자기 자신에 대한 값만 담고 있음

(3) 바이너리 인덱스 트리 : 업데이트(Update)
  - 특정 값을 변경할 때 : 0이 아닌 마지막 비트만큼 더하면서 -> 구간들의 값을 변경 (Ex) 3번째)
  - 바꾸고자 하는 특정 위치의 값부터 시작해서 -> 0이 아닌, 마지막 비트만큼 더하면서 -> 구간들의 값을 바꾸면 됨
  
  Ex) 3번째 값이 바뀐다고 할 때, 3은 0이 아닌 마지막 비트 = 1 이므로 
  -> 1칸 이동해서 4에 대한 값을 바꾸고
  -> 3는 0이 아닌 마지막 비트 = 4 이므로
  -> 4칸 이동해서 8에 대한 값을 바꾸고
  -> 8은 0이 아닌 마지막 비트 = 8이므로
  -> 8칸 이동해서 16에 대한 값을 바꾸어
  -> 3, 4, 8, 16 은 모두 3번째 값에 대한 합 정보를 담고 있는 인덱스임 ! 
  -> 총 4번 값을 업데이트 하면 됨 !

  - 데이터의 개수가 N 개 일 때 -> 높이는 O(logN) -> 특정 위치의 값을 바꿀 때, 최악의 경우에도 시간 복잡도 = O(logN) 을 보장

(4) 바이너리 인덱스 트리 : 누적 합(Prefix Sum)
 - 1 부터 N 까지의 합(누적 합) 구하기 : 0이 아닌 마지막 비트만큼 빼면서 구간들의 값의 합 계산 (Ex 11 번째까지의 합)

  Ex) 1 번째 원소부터 ~ 11 번째 원소까지의 구간 합을 구할 때 
  - 11 부터 출발해 - 인덱스 11인 11 하나에 대한 값을 담고 있고, 
  -> 11은 0이 아닌 마지막 비트 = 1 이므로
  -> 1만큼 빼서, 왼쪽으로 이동해서 9 번째 ~ 10 번째 까지의 값의 합을 담고 있는 인덱스 10 의 위치의 값을 더해주고
  -> 10은 0이 아닌 마지막 비트 = 2 이므로
  -> 2만큼 빼서, 왼쪽으로 이동해서 1 번째부터 ~ 8번째 까지의 모든 값의 합을 더한, 합계 값을 더하도록 함
  -> 1 ~ 11 번째 원소까지의 합을 구할 수 있음

  - 최악의 경우에도 O(logN) 에 비례하는 만큼만 연산을 수행하면 됨
  - 누적합을 구하는 연산에서 O(logN) 의 시간 복잡도를 보장할 수 있음


14. 최소 공통 조상(LCA, Lowest Common Ancestor)
 - 백준 11437번) LCA : O(M*N)으로 해결
 (1) 개념
  - 두 노드의 공통된 조상 중에서, 가장 가까운 조상을 찾는 문제

 (2) 최소 공통 조상 알고리즘
  1) 모든 노드에 대한 깊이(depth) 계산
  2) 최소 공통 조상을 찾을 두 노드를 확인
   2-1) 먼저, 두 노드의 깊이(depth) 가 동일하도록 거슬러 올라감
   2-2) 이후에, 부모가 같아질 때까지 반복적으로 두 노드의 부모 방향으로 거슬러 올라감
  3) 모든 LCA(a, b) 연산에 대해 2번의 과정을 반복함

 (3) 기본적인 최소 공통 조상(LCA) 알고리즘 : 연산 과정 살펴보기
   - DFS 를 이용해 모든 노드에 대해 깊이(depth)를 계산할 수 있음
   - LCA(8번 노드, 15번 노드)
    - 먼저 두 노드의 깊이를 맞춘다
    - 이후에 거슬러 올라감

 (4) 기본적인 최소 공통 조상(LCA) 알고리즘 : 시간 복잡도 분석
  - 매 쿼리마다 부모 방향으로 거슬러 올라가기 위헤 - 최악의 경우 O(N)의 시간 복잡도가 요구됨
  - 따라서, 모든 쿼리를 처리할 때의 시간 복잡도는 O(NM)

 (5) 최소 공통 조상(LCA) 알고리즘 개선하기
  1) 각 노드가 거슬러 올라가는 속도를 빠르게 만드는 방법에 대해 고민
   - 만약, 총 15칸 거슬러 올라가야 한다면?
    - 8칸 -> 4칸 -> 2칸 -> 1칸
   - 2의 제곱 형태로 거슬러 올라가도록 하면 -> O(logN) 의 시간복잡도 보장 가능
   - 메모리를 조금 더 사용하여 -> [각 노드에 대해 2^i 번째 부모에 대한 정보]를 기록

  2) 모든 노드의 깊이와 부모 구하기
   - 모든 노드에 대하여 깊이(depth)와 2번째 부모에 대한 정보를 계산
    - 먼저, dfs 를 호출해서 - 각각 자신의 한 단계 위의 부모를 확인하도록 하고 
    -> 그 정보를 이용해, 다이나믹 프로그래밍을 활용해 각각의 2^i 번째 무보에 대한 정보를 모두 구할 수 있음
      Ex) 노드 15에 대해 -> 위로 거슬러 올라가며 부모를 기록하면서
          i = 0   i = 1   i = 2
            11      5       1
          1단계 위  2단계 위  4단계 위 -> 모든 노드에 대해 각각의 정보를 테이블에 기록
                                  -> 노드의 개수가 N 개 일 때 -> N * log(N) 만큼의 공간이 필요 - 시간 효율성은 향상(트레이드 오프)
  
  (6) 개선된 최소 공통 조상(LCA) 알고리즘 : 연산 과정 살펴보기
   - LCA(13번 노드, 15번 노드)
    - 먼저, 두 노드의 깊이를 맞춘다.
      - 올라가야 하는 크기가 있다면, 2의 제곱 꼴로 빠르게 올라갈 수 있도록
    - 이후에 거슬러 올라간다.
      - 거슬러 올라갈 때, 가능하면 2의 제곱 꼴로 빠르게 거슬러 올라갈 수 있도록 함

  (7) 개선된 최소 공통 조상(LCA) 알고리즘 : 시간 복잡도 분석
   1) 다이나믹 프로그래밍(dynamic programming)을 이용해 -> 시간 복잡도 개선 가능
    - 세그먼트 트리를 이용하는 방법도 존재
   2) 매 쿼리마다 부모를 거슬러 올라가기 위헤, O(logN) 의 복잡도가 필요
    - 따라서, 모든 쿼리를 처리할 때의 시간 복잡도는 O(MlogN)
    

15. 벨만 포드 알고리즘
 - 음수 간선이 포함된 상황에서의 최단 거리 문제
  - 음수 간선의 순환이 포함되어 있는 경우 -> 최단 거가 음의 무한인 노드가 발생

 (1) 음수 간선에 대한 최단 경로 문제 분류
  1) 모든 간선이 양수인 경우
  2) 음수 간선이 있는 경우
   2-1) 음수 간선 순환은 없는 경우
   2-2) 음수 간선 순환이 있는 경우 

 (2) 벨만 포드 최단 경로 알고리즘은 [음수 간선이 포함된 상황에서도 사용 가능]
  1) 음수 간선의 순환 감지 가능
  2) 벨만 포드의 기본 시간 복잡도는 O(VE) 로 다익스트라 알고리즘에 비해 느림
   - 다익스트라 알고리즘 시간 복잡도 = O(ElogV)

 (3) 벨만 포드 최단 경로 알고리즘
  1) 출발 노드 설정
  2) 최단 거리 테이블 초기화
  3) 다음의 과정을 N-1 번 반복
   3-1) 전체 간선 E 개를 하나씩 확인
   3-2) 각 간선을 거쳐, 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신
    - 만약, 음수 간선 순환이 발생하는지 체크하고 싶다면, 3번의 과정을 한 번 더 수행
      - 이때, 최단 거리 테이블이 갱신된다면 -> 음수 간선 순환이 존재하는 것
    - 벨만 포드 알고리즘이 다익스트라 알고리즘의 옵티멀한 솔루션을 포함

 (4) 벨만 포드 알고리즘 Vs 다익스트라 알고리즘
  1) 다익스트라 알고리즘
   - 매번  방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택
   - 음수 간선이 없다면, 최적의 해를 찾을 수 있음

  2) 벨만 포드 알고리즘
   - 매번 모든 간선을 전부 확인
      - 따라서, 다익스트라 알고리즘에서의 최적의 해를 항상 포함
   - 다익스트라 알고리즘에 비해서, 시간이 오래 걸리지만 음수 간선 순환을 탐지할 수 있음