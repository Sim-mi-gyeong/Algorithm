1. 소수(Prime Number)
 1) 소수의 개념
  - 소수란, 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수
   Ex) 6은 1, 2, 3, 6으로 나누어 떨어짐 -> 소수 x
   Ex) 7은 1, 7을 제외하고는 나누어 떨어지지 X -> 소수
 2) 코딩 테스트에서, 어떠한 자연수가 소수인지 아닌지 판별해야 하는 문제 자주 출제

 3) 소수의 판별 - 기본적인 알고리즘 성능 분석
  - 2부터 X-1 까지의 모든 자연수에 대해 연산 수행
  -> 모든 수를 하나씩 확인한다는 점에서, 시간 복잡도 = O(X) -> 선형적으로 비례


2. 약수의 성질
 1) 모든 약수가 가운데 약수를 기준으로, 곱셈 연산에 대해 대칭을 이룸
  Ex) 16의 약수 : 1, 2, 4, 8, 16
   -> 이때, 2 X 8 = 16은 8 X 2 = 16과 대칭
 2) 따라서, 특정한 자연수의 모든 약수를 찾을 때 '가운데 약수(제곱근)까지만 확인'하면 된다.
  Ex) 16이 2로 나누어 떨어진다는 것은 -> 8로도 나누어 떨어진다는 것을 의미
 3) 이 성질을 이용해 소수 판별 알고리즘 개선 가능
 4) 소수의 판별 - 개선된 알고리즘 성능 분석
  - 2부터 X의 제곱근(소수점 이하 무시)까지의 모든 자연수에 대해 연산 수행
  -> 시간 복잡도 = O(N^1/2)


3. 다수의 소수 판별 - 에라토스테네스 체 알고리즘
 - 하나의 수에 대해 소수인지/아닌지를 판별하는 방법이 아닌, 
 - 특정한 수의 범위 안에 존재하는 '모든 소수'를 찾아야 할 때 -> '에라토스테네스 체 알고리즘' 사용 가능

 (1) 개념
  - 다수의 자연수에 대해 소수 여부를 판별할 때 사용되는 대표적인 알고리즘
  - 에라토스테네스 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용 가능

 (2) 에라토스테네스 체 알고리즘의 동작 과정
  1) 2부터 N 까지의 모든 자연수 나열
  2) 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다
  3) 남은 수 중에서 i의 배수를 모두 제거(i는 제거하지 않는다)
  4) 더 이상 반복할 수 없을 때까지 2번과 3번의 과정 반복

 (3) 에라토스테네스 체 알고리즘 성능 분석
  1) 에라토스테네스 체 알고리즘의 시간 복잡도는, 사실상 선형 시간에 가까울 정도로 매우 빠름
   - 시간 복잡도 = O(NlogN)
  2) 에라토스테네스 체 알고리즘은, 다수의 소수를 찾아야 하는 문제에서 효과적으로 사용 가능
   - 하지만, 각 자연수에 대한 소수 판별 여부를 저장해야 하므로 '메모리가 많이 필요'
   -> 10억이 소수인지/아닌지를 판별해야 할 때 에라토스테네스 체를 사용할 수 있는가?


4. 투 포인터(Tow Pointer) 
 (1) 투 포인터 알고리즘 개념(정의)
  - 투 포인터 알고리즘은, '리스트에 순차적으로 접근해야 할 때 -> 두 개의 점의 위치를 기록하면서 처리' 하는 알고리즘
  Ex) 흔히, 2, 3, 4, 5, 6, 7번 학생을 지목해야 할 때 -> 간단히 2번부터 7번까지의 학생이라고 부름
  - 리스트에 담긴 데이터에 순차적으로 접근해야 할 때는 -> '시작점과 끝점' 2개의 점으로 접근할 데이터의 범위 표현 가능

5. 특정한 합을 가지는 부분 연속 수열 찾기
 (1) 문제 설명
 - N 개의 자연수로 구성된 수열
 - 합이 M 인 부분 연속 수열의 개수는 ?
 - 수행 시간 제한은 O(N)

 (2) 문제 해결 아이디어
  - 투 포인터를 활용해 다음과 같은 알고리즘으로 문제 해결 가능
  1) 시작점(start)과 끝점(end)이 첫 번째 원소의 인덱스(0)를 가리키도록 한다.
  2) 현재 부분 합이 M과 같아면 -> 카운트
  3) 현재 부분 합이 M보다 작다면 -> end를 1 증가 -> 현재의 부분 합 증가
  4) 현재 부분 합이 M보다 크거나 같아면, start 1 증가 -> 현재의 부분 합 감소
  5) 모든 경우를 확인할 때까지, 2번부터 4번까지의 과정 반복

 (3) 동작 과정 
  - M = 5
  [초기 단계] 시작점과 끝점이 첫 번째 원소의 인덱스를 가리키도록 한다.
   - 현재의 부분합이 1이므로 무시
   - 현재 카운트 : 0
  [Step 1] 이전 단계에서의 부분합이 1이었기 때문에 -> end를 1 증가
   - 현재의 부분합은 3이므로 무시
   - 현재 카운트 : 0
  [Step 2] 이전 단계에서의 부분합 = 3 -> end를 1 증가
   - 현재의 부분합 = 6이므로 무시
   - 현재 카운트 : 0
  [Step 3] 이전 단계에서의 부분합 = 6 -> start를 1 증가  
   - 현재의 부분합 = 5 -> 카운트 증가
   - 현재 카운트 : 1
  [Step 4]  이전 단계에서의 부분합 = 5 -> start를 1 증가  
   - 현재의 부분합 = 3 
   - 현재 카운트 : 1
  [Step 5]  이전 단계에서의 부분합 = 3 -> end 1 증가  
   - 현재의 부분합 = 5 -> 카운트 증가
   - 현재 카운트 : 2
  [Step 6]  이전 단계에서의 부분합 = 5 -> start 1 증가  
   - 현재의 부분합 = 2
   - 현재 카운트 : 2   
  [Step 7]  이전 단계에서의 부분합 = 2 -> end 1 증가  
   - 현재의 부분합 = 7
   - 현재 카운트 : 2   
  [Step 6]  이전 단계에서의 부분합 = 7 -> start 1 증가  
   - 현재의 부분합 = 5 -> 카운트 증가
   - 현재 카운트 : 3   


6. 구간 합(Interval Sum)
 (1) 구간 합 문제
  - 연속적으로 나열된 N개의 수가 있을 때, 특정 구간의 모든 수를 합한 값을 계산하는 문제
  Ex) 5개의 데이터로 구성된 수열 {10, 20, 30, 40, 50} 이 있을 때
   - 두 번째 수 ~ 네 번째 수까지의 합 : 20 + 30 + 40 = 90

 (2) 구간 합 빠르게 계산하기 - 문제 설명
  1) N 개의 정수로 구성된 수열 존재
  2) M 개의 쿼리(Query) 정보가 주어짐
   - 각 쿼리는 Left와 Right 로 구성됨
   - 각 쿼리에 대해, [Left, Right] 구간에 포함된 데이터들의 합을 출력
  3) 수행 시간 제한은 O(N + M)

 (3) 구간 합 빠르게 계산하기 - 문제 해결 아이디어
  1) 접두사 합(Prefix Sum)
   - 배열의 맨 앞부터 ~ 특정 위치까지의 합을 미리 구해 놓은 것
  2) 접두사 합을 활용한 알고리즘
   - N 개의 수 위치 각각에 대해 접두사 합을 계산하여 P에 저장
   - 매 M개의 쿼리 정보를 확인할 때 구간 합은 P[Right] - P[Left - 1]


7. 우선순위 큐(Priority Queue)
 (1) 정의
  - 우선순위 큐는, '우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조'
  - 데이터를 우선순위에 따라 처리하고 싶을 때 사용
  Ex) 물건 데이터를 자료구조에 넣었다가 -> 가치가 높은 물건부터 꺼내서 확인해야 하는 경우

 (2) 자료구조에 따른 추출되는 데이터
  1) 스택(Stack) - 가장 나중에 삽입된 데이터
  2) 큐(Queue) - 가장 먼저 삽입된 데이터
  3) 우선순위 큐(Priority Queue) - 가장 우선순위가 높은 데이터

 (3) 우선순위 큐의 구현 방법
  1) 단순히 리스트를 이용한 구현
  2) 힙(Heap)을 이용한 구현

 (4) 데이터의 개수가 N개일 때, 구현 방식에 따른 시간 복잡도는,
    
    우선순위 큐 구현 방식      삽입 시간      삭제 시간
        리스트               O(1)         O(N)
       힙(Heap)           O(logN)       O(logN)
  
  - 리스트의 경우, 삭제할 데이터를 탐색(가장 우선순위가 높은 데이터 찾기)해야 하므로 선형적인 탐색 시간 필요
  - 힙은, 최악의 경우에도 O(logN)

 (5)단순히 N개의 데이터를 힙에 넣었다가 -> 모두 꺼내는 작업 = 정렬과 동일(힙 정렬)
   -> 이 경우, 시간 복잡도는 O(NlogN) (병합 정렬도 같은 시간 복잡도)


8. 힙(Heap)의 특징
 (1) 힙 자료구조 정의
  - 힙은, '완전 이진 트리 자료구조'의 일종
  - 힙에서는 항상 '루트 노드(root node)'를 제거
  1) 최소 힙(min heap)
   - 루트 노드가 가장 작은 값을 가진다.
   - 따라서, 값이 작은 데이터가 우선적으로 제거됨
  2) 최대 힙(max heap)
   - 루트 노드가 가장 큰 값을 가진다.
   - 따라서, 값이 큰 데이터가 우선적으로 제거됨

 (2) 완전 이진 트리(Complete Binary Tree)
  - 완전 이진 트리란, 루트(root) 노드부터 시작하여 -> 왼쪽 자식 노드, 오른쪽 자식 노드 순서대로
    데이터가 차례대로 삽입되는 트리(tree)


9. 힙 연산
 (1) 최소 힙 구성 함수 : Min-Heapify()
  1) 개념
   - (상향식) 부모 노드로 거슬러 올라가며 -> 부모보다 > 자신의 값이 더 작은 경우 -> 위치 교체
  2) 힙에 새로운 원소가 삽입될 때
   - 새로운 원소가 삽입되었을 때 -> O(logN)의 시간 복잡도로 힙 성질 유지 가능
  3) 힙에서 원소가 제거될 때
   - 원소가 제거되었을 때 -> O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있음
   - 원소를 제거할 때는, 가장 마지막 노드가 루트 노드의 위치로 오도록
   -> 이후에 '루트 노드에서부터 하향식으로(더 작은 자식 노드로)' Heapify()를 진행


10. 트리(Tree) 자료구조
 (1) 개념
  - 트리는, 가계도와 같은 '계층적인 구조'를 표현할 때 사용 가능한 자료구조
 (2) 트리 관련 용어
  - 루트 노드(root node) : 부모가 없는 최상위 노드
  - 단말 노드(leaf node) : 자식이 없는 노드
  - 크기(size) : 트리에 포함된 모든 노드의 개수
  - 깊이(depth) : 루트 노드부터의 거리
  - 높이(height) : 깊이 중 최댓값
  - 차수(degree) : 각 노드의 (자식 방향) 간선 개수
   -> 기본적으로, 트리의 크기가 N일때 -> 전체 간선의 개수는 N-1 개


11. 이진 탐색 트리(Binary Search Tree) - 탐색의 시간 복잡도 : O(logN)는 이진 탐색 트리가 이미 구성되어 있을 떄 !
 (1) 개념
  1) 이진 탐색이 동작할 수 있도록 고안된, 효율적인 탐색이 가능한 자료구조의 일종
  2) 이진 탐색 트리의 특징 : 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
   - 부모 노드보다 > 왼쪽 자식 노드가 작음
   - 부모 노드보다 < 오른쪽 자식 노드가 큼

 (2) 이진 탐색 트리에서 데이터 조회 과정
  - 이진 탐색 트리가 이미 구성되어 있다고 가정하고, 데이터를 조회하는 과정
  - 찾고자 하는 원소 : 37
  [Step 1] 루트 노드부터 방문하여 탐색 진행
   - 현재 노드(30)와 찾는 원소(37)를 비교
   - 찾는 원소가 더 크므로 -> 오른쪽 방문(탐색 범위가 절반으로 줄어듬)
   -> 탐색 범위가 절반으로 줄어듬
  [Step 2] 현재 노드와 값을 비교
   - 현재 노드(48)와 찾는 원소(37)를 비교
   - 찾는 원소가 더 작으므로 -> 왼쪽 방문
  [Step 3] 현재 노드와 값을 비교
   - 현재 노드(37)와 찾는 원소(37)을 비교
   - 원소를 찾았으므로 -> 탐색 종료


12. 트리의 순회(Tree Traversal)
 (1) 개념
  - 트리 자료구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하는 방법
  - 트리의 정보를 시각적으로 확인 가능
 (2) 트리 순회 방법 종류
  1) 전위 순회(pre-oreder traversal) : 루트를 먼저 방문
  2) 중위 순회(in-order traversal) : 왼쪽 자식을 방문한 뒤에 -> 루트 방문
  3) 후위 순회(post-order traversal) : 왼쪽 자식을 먼저 방문하고 -> 오른쪽 자식을 방문한 뒤에 -> 루트 방문
   - 후위 순회는, 왼쪽을 방문하고 -> (자기 자신으로 올라와) -> 오른쪽을 방문하고 -> 자기 자신을 방문

 (3) 트리 순회 예시
  Ex) 입력 예시
      7
      A B C
      B D E
      C F G
      D None None
      E None None
      F None None
      G None None
  1) 전위 순회 : A -> B -> D -> E -> C -> F -> G
  2) 중위 순회 : D -> B -> E -> A -> F -> C -> G
  3) 후위 순회 : D -> E -> B -> F -> G -> C -> A