# 문제 해결 아이디어

# ai = 금액 i를 만들 수 있는 최소한의 화폐 개수
# k = 각 화폐의 단위
# 점화식 : 각 화폐 단위인 k를 하나씩 확인하며

# ai-k를 만드는 방법이 존재하는 경우 -> ai = min(ai, ai-k + 1)
# (i-k)원을 만들 수 있다고 하면, 현재 확인하고 있는 단위인 k를 하나 더 추가해서, i원을 만들 수 있기 때문
# 더 적은 화폐 단위를 사용할 수 있는 경우로 Update 

# ai-k를 만드는 방법이 존재하지 않는 경우 -> ai = INF(임의의 무한대 값)

# 각각의 화폐 단위를 확인하며, 그때마다 
# 반복문을 이용해 (ai-k)원을 만들 수 있는/없는 경우의 공식대로 테이블의 값을 갱신
# -> 따라서, n * m 만큼의 시간 복잡도

# Ex) n = 3, m = 7 이고, 각 화폐 단위가 2, 3, 5인 경우
# [Step 0] 초기화

# 먼저, 각 인덱스에 해당하는 값으로 INF(무한, 특정 금액을 만들 수 있는 화폐 구성 불가 의미)의 값 설정
# [Step 1]
# 첫 번째 화폐 단위인 2 확인
# 만약, index i를 확인하며, (i-2) 금액을 만들 수 있다면, 금액 i 또한 만들 수 있음을 의미.

# [Step 2, 3]
# 두 번째 화폐 단위인 3, 5 확인

n, m = map(int, input().split())
arr = []
for i in range(n): arr.append(int(input()))

# 한 번 계산된 결과 저장을 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# DP(Bottom Up)
d[0] = 0
# i : 각 화폐 단위 / j : 각 금액
for i in range(n):   # 화폐 종류 리스트에서 인덱스
    for j in range(arr[i], m + 1):   # (arr[i] = 화폐 종류의 값) ~ : 화폐 단위에 해당하는 금액부터 시작 
        if d[j - arr[i]] != 10001:   # (i - k)원을 만드는 방법이 존재하는 경우 (-> i원 또한 만들 수 있음)
            d[j] = min(d[j], d[j - arr[i]] + 1)   # 해당 화폐 종류 하나를 더 추가해 그 금액을 만듦

if d[m] == 10001: print(-1)
else: print(d[m])
