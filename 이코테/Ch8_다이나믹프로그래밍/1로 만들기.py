# 문제 해결 아이디어
# 피보나치 수열과 유사한 트리 구조
# 최적 부분 구조 : 각 값을 구하기 위해 그것보다 작은 문제의 값들이 사용된다는 점에서 성립
# 중복되는 부분 문제 : 동일한 문제가 여러 번 호출

# 그리디 문제 중 '1이 될 때까지' 문제와의 차이
# 해당 변수가 어떤 값을 가지던지 간에, 1을 빼는 것보다 나누는 작업이 더 빨리 값을 줄일 수 있으므로
# 나누어 떨어진다면, 나누는 것이 빠름

# 본 문제에서는, 5로 나누었을 때 값을 많이 줄일 수 있더라도, 다른 연산을 적절히 섞어 더 빨리 값을 줄일 수 있는 경우 존재 가능 

# ai = [i를, 1로 만드는 최소 연산 횟수]라고 할 때,
# 점화식 : ai = min(ai-1, ai/2, ai/3, ai/5) + 1
# 단, 1을 빼는 연산을 제외하고는 '해당 수로 나누어 떨어질 때에 한해 점화식 적용 가능'
# ai/2 = i를 2로 나눈 값의 optimal solution 
# + 1 : min()에서 가장 작은 값을 골라, 한 번의 연산이 수행된 것이므로 + 1 

n = int(input())
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001
# 1 -> 자기 자신이 1이므로 0으로 초기화

# DP 진행(보텀업)
# 2일때부터 입력으로 들어온 n에 대해 각각 Optimal Solution 값을 구함
# 이때, 4가지 연산 경우 중 가장 적은 값을 가지는 것을 골라 +1 한 값을 넣을 수 있도록 점화식 설정
for i in range(2, n+1):   
    # 현재의 수에서 1을 빼는 경우(에서의 Optimal Solution 값 + 1을 한 값)
    d[i] = d[i-1] + 1
    # 4가지 경우 중 가장 작은 값을 저장해야 하므로, min()을 통해 가장 작은 값이 존재한다면, d[i] 해당 값을 바꿀 수 있도록 업데이트 
    # 현재의 수가 2로 나누어 떨어지는 경우
    # [2로 나눈 위치에서의 Optimal Solution 값 + 1] 값과 비교해 작은 값이 들어갈 수 있도록
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[n])