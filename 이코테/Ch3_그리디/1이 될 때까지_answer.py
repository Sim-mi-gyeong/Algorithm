# 문제 해결 아이디어
# 주어진 N에 대해 최대한 많이 나누기 수행
# N의 값을 줄일 때 2 이상의 수로 나누는 작업이 1을 빼는 작업보다 수를 훨씬 많이 줄일 수 있음

# 정당성 분석
# 가능하면 최대한 많이 나누는 작업이 최적의 해를 보장 ? 
# -> N이 아무리 큰 수여도, K로 계속 나눈다면 기하급수적으로 빠르게 줄일 수 있음.
# -> K가 2 이상이기만 하면, K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있음

# n, k를 공백 기준으로 구분하여 입력 받기
n, k = map(int, input().split())

result = 0

while True:
    # n이 k로 나누어 떨어지는 수가 될 때까지 빼기
    # Technic: 코드 실행 시, n과 k가 매우 커도 log 시간 복잡도로 수행 가능
    # target: k로 나누어 떨어지는 수 
    target = (n // k) * k   # 만약, n이 k로 나누어 떨어지지 않을 때, 가장 가까운, k로 나누어 떨어지는 수를 찾기 위함.
    result += (n - target)   # 1을 빼는 연산을 몇 번 할지 계산
    n = target

    # n이 k 보다 작을 때(더 이상 나눌 수 없을 때) 반복문 탈출
    if n < k:
        break
    # k로 나누기
    result += 1
    n  //= k

# 마지막으로 남은 수에 대해 1씩 빼기
result += (n - 1)
print(result)