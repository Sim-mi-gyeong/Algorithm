정렬 알고리즘
- 정렬(sort): 데이터를 특정한 기준에 따라 순서대로 나열하는 것

1. 선택 정렬 알고리즘
(1) 정의
 - 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것 반복

(2) 동작 원리 
 - 마지막 경우는 처리하지 않아도 됨.
 - 탐색 범위는 반복할 때마다 줄어들게 되고, 매번 가장 작은 원소를 찾기 위해 탐색 범위만큼 데이터를 하나씩 확인해서
   가장 작은 데이터를 찾아야 함. -> 선형 탐색 수행 -> 이중 for문

(3) 시간 복잡도
 - 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 함
 -> 구현 방식에 따라 사소한 오차가 있을 수 있지만, 전체 연산 횟수는 N + (N-1) + (N-2) + ... + 2 (등차수열)
 -> (N^2 + N - 2) / 2 -> O(N^2)

2. 삽입 정렬
(1) 정의
 - 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
 - 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작

(2) 동작 원리
 - 왼쪽에 있는 데이터와 비교하여 매번 위치를 바꾸어 가며 작동

(3) 시간 복잡도
 - 삽입 정렬의 시간 복잡도는 O(N^2)이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용
 - 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태일 때 매우 빠르게 동작
 -> 최선의 경우, O(N)의 시간 복잡도를 가짐
 -> if) 이미 정렬되어 있는 상태에서, 다시 삽입 정렬을 수행하면?
 -> 오름차순 정렬을 수행한다고 했을 때, 바로 왼쪽의 원소와 비교해 그 원소보다 크면 반복 멈춤
 -> 각 원소가 들어갈 위치를 고를 때, 선형탐색(0(N))

3. 퀵 정렬
(1) 정의
 - [기준 데이터]를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
 - 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나씩
 - 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
 - 가장 기본적인 퀵 정렬은 '첫 번째 데이터'를 '기준 데이터(Pivot)'로 설정!

(2) 동작 원리
 1) Pivot 값에 대해 왼쪽에서 부터는 Pivot보다 큰 데이터를 선택
 2) Pivot 값에 대해 오른쪽에서 부터는 Pivot보다 작은 데이터를 선택해
 -> 두 데이터의 위치를 서로 변경
 -> '위치가 엇갈리는 경우' [피벗]과 [작은 데이터]의 위치를 서로 변경
 -> [분할 완료] 왼쪽에 있는 데이터는 모두 Pivot 보다 작고, 오른쪽에 있는 데이터는 모두 Pivot 보다 크다
 -> Pivot을 기준으로 데이터 묶음을 나누는 작업 = [분할(Divide)/Partition]
 -> Pivot 기준 왼쪽 / 오른쪽에 있는 데이터들 각각을 배열로 판단해 퀵 정렬 수행하면
 -> 퀵 정렬이 수행되는 과정을 '재귀적'으로 수행
 -> 정렬의 수행 범위가 점점 좁아짐

(3) 시간 복잡도
 - 이상적인 경우 분할이 절반씩 일어난다면, 전체 연산 횟수로 O(NlogN)을 기대할 수 있음
 - 너비(데이터의 개수) X 높이(분할 횟수) = N * logN = NlogN
 -> 퀵 정렬은 평균의 경우 O(NlogN)의 시간 복잡도를 가짐
 - 하지만 최악의 경우, O(N^2)의 시간 복잡도를 가짐
 -> if) 첫 번째 원소를 피벗으로 삼을 때, 이미 정렬된 배열에 대해서 퀵 정렬을 수행하면?
 -> 피벗 값 자기 자신에서 자기 자신의 위치로 변경이 이루어짐
 -> 분할이 이루어졌을 때 왼쪽은 분할이 이루어지지 않고, 오른쪽 데이터들만 남는 형태로 분할이 이루어짐
 -> 오른쪽 데이터들에 대해 또 퀵 정렬 수행(분할이 수행되는 횟수가 N번)
 -> 분할을 하기 위해 매번 선형탐색을 해야하므로 전체 시간 복잡도가 O(N^2)

  + 표준 정렬 라이브러리를 사용할 경우, 최악의 경우에도 NlogN을 보장

4. 계수 정렬
 - 각 데이터가 몇 번씩 등장했는지 개수를 세는 방식으로 동작
 - 가장 작은 데이터부터 가장 큰 데이터 범위까지를 담을 수 있는 배열 크기를 만들어야 함 -> 공간 복잡도 높음
(1) 정의
 - 특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠르게 동작하는 정렬 알고리즘
 -> 계수 정렬을 데이터의 크기 범위가 제한되어, 정수 형태로 표현할 수 있을 때 사용 가능
 - 데이터의 개수가 N, 데이터(양수) 중 최댓값이 K 일 때 - 최악의 경우에도 수행 시간 O(N + K)를 보장

(2) 동작 원리
 1) [Step 0] 가장 작은 데이터부터 ~ 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트 초기화
  - 리스트의 각각의 인덱스가 각 데이터 값에 해당함
  -> 각각의 데이터가 몇 번씩 등장했는지 그 개수를 셈
  - 배열에서 특정 인덱스에 접근할 때 알고리즘 상으로, 상수 시간이 걸림
  -> 데이터를 하나씩 확인하며, 그 데이터와 동일한 인덱스에 count 값을 +1씩 증가
 2) [Step 1] 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터(계수 값)를 1씩 증가
 3) 결과적으로, 최종 리스트에는 각 데이터가 몇 번씩 등장했는지 그 횟수가 기록됨.
 4) 결과 확인할 때 - 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 반복하며 인덱스 출력

(3) 복잡도 분석
 - 계수 정렬의 시간 복잡도 & 공간 복잡도 = O(N + K)
 - 계수 정렬은 때에 따라 심각한 비효율성 초래 가능
  Ex) 데이터가 0과 999,999로 단 2개만 존재하는 경우는
 - 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용 가능
  Ex) 성적의 경우 100점을 맞는 학생이 여러 명일 수 있어 계수 정렬이 효과적


[정렬 알고리즘 비교]
- 대부분의 프로그래밍 언어에서 지원하는 표준 정렬 라이브러리는 최악의 경우에도 O(NlogN)을 보장하도록 설계
  정렬 알고리즘    평균 시간 복잡도     공간 복잡도     특징
   선택 정렬        O(N^2)           O(N)       아이디어가 매우 간단
   삽입 정렬        O(N^2)           O(N)       데이터가 거의 정렬되어 있을 떄 가장 빠름
    퀵 정렬        O(NlogN)         O(N)        대부분의 경우에 가장 적합, 충분히 빠름
   계수 정렬        O(N+K)          O(N+K)      데이터의 크기가 한정된 경우에만 사용 가능, but 매우 빠르게 동작

* python의 표준 정렬 라이브러리: 병합 정렬 기반의 하이브리드 방식의 정렬 알고리즘
-> 최악의 경우에도, O(NlogN)의 시간 복잡도 보장


5. 위상 정렬 - 그래프 이론
(1) 정의
 - 사이클이 없는 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것
 Ex) 선수과목을 고려한 학습 순서 설정
     자료구조    -------->    알고리즘
       |                      |
       |                      |
       |                      |
        ----> 고급 알고리즘 <-----
  -> 위의 세 과목을 모두 듣기 위한 적절한 학습 순서는?
  1) 자료구조 -> 알고리즘 -> 고급 알고리즘 (O)
  2) 자료구조 -> 고급 알고리즘 -> 알고리즘 (X)

(2) 진입차수와 진출차수
 - 그래프 관련 자료구조에서 자주 등장하는 개념
 1) 진입차수(Indegree) : 특정한 노드로 들어오는 간선의 개수
 2) 진출차수(Outdegree) : 특정한 노드에서 나가는 간선의 개수

        1       -------->      2
        |                      |
        |                      |
        |                      |
        ------->   3   <-------

   - 1번) 진입차수 = 0 / 진출차수 = 2
   - 2번) 진입차수 = 1 / 진출차수 = 1
   - 3번) 진입차수 = 2 / 진출차수 = 0

(3) 위상 정렬 알고리즘 - 큐 / dfs 를 사용해 구현 가능
  - 큐를 이용하는 위상 정렬 알고리즘의 동작 과정
  1) 진입차수가 0인 모든 노드를 큐에 넣는다.
  2) 큐가 빌 때까지 다음 과정 반복
   2-1) 큐에서 원소를 꺼내 -> 해당 노드에서 나가는 간선을 그래프에서 제거
   2-2) 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.

-> 결과적으로, 각 노드가 큐에 들어온 순서 = 위상 정렬을 수행한 결과

(4) 위상 정렬 동작 예시
 - 위상 정렬을 수행할 그래프 준비
 -> 이때, 그래프는 [사이클이 없는 방향 그래프(DAG] 이어야 함
 -> 만약 사이클이 존재한다면, 사이클에 포함되어 있는 모든 노드는 진입차수가 1 이상이 된다.

         2     3     4

    1    
        
         5     6     7

    1 -> 2 / 1 -> 5 / 2 -> 3 / 2 -> 6 / 3 -> 4 / 4 -> 7 / 5 -> 6 / 6 -> 4

 [초기 단계] 초기 단계에서는 진입차수가 0인 모든 노드를 큐에 넣음
  - 처음에 노드 1이 큐에 삽입됨
 [Step 1] 큐에서 노드 1을 꺼낸 뒤에 노드 1에서 나가는 간선을 제거
  - 새롭게 진입차수가 0이 된 노드들을 큐에 삽입 -> 큐 : 노드 2, 노드 5
 [Step 2] 큐에서 노드 2를 꺼낸 뒤에 노드 2에서 나가는 간선을 제거
  - 새롭게 진입차수가 0이 된 노드를 큐에 삽입 -> 큐 : 노드 5, 노드 3
 [Step 3] 큐에서 노드 5를 꺼낸 뒤에 노드 5에서 나가는 간선을 제거
  - 새롭게 진입차수가 0이 된 노드를 큐에 삽입 -> 큐 : 노드 3, 노드 6
 [Step 4] 큐에서 노드 3을 꺼낸 뒤에 노드 3에서 나가는 간선을 제거
  - 새롭게 진입차수가 0이 된 노드가 없으므로, 그냥 넘어감 -> 큐 : 노드 6
 [Step 5] 큐에서 노드 6을 꺼낸 뒤에 노드 노드 6에서 나가는 간선을 제거
  - 새롭게 진입차수가 0이 된 노드를 큐에 삽입 -> 큐 : 노드 4
 
 [위상 정렬 결과] 큐에 삽입된 전체 노드 순서 : 1-> 2 -> 5 -> 3 -> 6 -> 4 -> 7


(5) 위상 정렬 특징
 1) 위상 정렬은 DAG에 대해서만 수행 가능
  - DAG(Direct Acyclic Graph) : 순환하지 않는 방향 그래프
 2) 위상 정렬에서는 여러 가지 답이 존재할 수 있음
  - 한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우가 있다면, 여러 가지 답이 존재
 3) 모든 원소를 방문하기 전에 큐가 빈다면, 사이클이 존재한다고 한단할 수 있음
  - 사이클에 포함된 원소 중에서 어떠한 원소도 큐에 들어가지 못함
 4) 스택을 활용한 DFS를 이용해 위상 정렬 수행 가능


(6) 위상 정렬 알고리즘 성능 분석
 - 위상 정렬을 위해 차례대로 모든 노드를 확인하며 각 노드에서 나가는 간선을 차례대로 제거해야 함
 - 위상 정렬 알고리즘의 시간 복잡도 = O(V+E)