정렬 알고리즘
- 정렬(sort): 데이터를 특정한 기준에 따라 순서대로 나열하는 것

1. 선택 정렬 알고리즘
(1) 정의
 - 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것 반복
(2) 동작 원리 
 - 마지막 경우는 처리하지 않아도 됨.
 - 탐색 범위는 반복할 때마다 줄어들게 되고, 매번 가장 작은 원소를 찾기 위해 탐색 범위만큼 데이터를 하나씩 확인해서
   가장 작은 데이터를 찾아야 함. -> 선형 탐색 수행 -> 이중 for문
(3) 시간 복잡도
 - 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 함
 -> 구현 방식에 따라 사소한 오차가 있을 수 있지만, 전체 연산 횟수는 N + (N-1) + (N-2) + ... + 2 (등차수열)
 -> (N^2 + N - 2) / 2 -> O(N^2)

2. 삽입 정렬
(1) 정의
 - 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
 - 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작
(2) 동작 원리
 - 왼쪽에 있는 데이터와 비교하여 매번 위치를 바꾸어 가며 작동
(3) 시간 복잡도
 - 삽입 정렬의 시간 복잡도는 O(N^2)이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용
 - 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태일 때 매우 빠르게 동작
 -> 최선의 경우, O(N)의 시간 복잡도를 가짐
 -> if) 이미 정렬되어 있는 상태에서, 다시 삽입 정렬을 수행하면?
 -> 오름차순 정렬을 수행한다고 했을 때, 바로 왼쪽의 원소와 비교해 그 원소보다 크면 반복 멈춤
 -> 각 원소가 들어갈 위치를 고를 때, 선형탐색

3. 퀵 정렬
(1) 정의
 - [기준 데이터]를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
 - 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나씩
 - 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
 - 가장 기본적인 퀵 정렬은 '첫 번째 데이터'를 '기준 데이터(Pivot)'로 설정!

(2) 동작 원리
 1) Pivot 값에 대해 왼쪽에서 부터는 Pivot보다 큰 데이터를 선택
 2) Pivot 값에 대해 오른쪽에서 부터는 Pivot보다 작은 데이터를 선택해
 -> 두 데이터의 위치를 서로 변경
 -> '위치가 엇갈리는 경우' [피벗]과 [작은 데이터]의 위치를 서로 변경
 -> [분할 완료] 왼쪽에 있는 데이터는 모두 Pivot 보다 작고, 오른쪽에 있는 데이터는 모두 Pivot 보다 크다
 -> Pivot을 기준으로 데이터 묶음을 나누는 작업 = [분할(Divide)/Partition]
 -> Pivot 기준 왼쪽 / 오른쪽에 있는 데이터들 각각을 배열로 판단해 퀵 정렬 수행하면
 -> 퀵 정렬이 수행되는 과정을 '재귀적'으로 수행
 -> 정렬의 수행 범위가 점점 좁아짐

(3) 시간 복잡도
 - 이상적인 경우 분할이 절반씩 일어난다면, 전체 연산 횟수로 O(NlogN)을 기대할 수 있음
 - 너비 X 높이 = N * logN = NlogN
 -> 퀵 정렬은 평균의 경우 O(NlogN)의 시간 복잡도를 가짐
 - 하지만 최악의 경우, O(N^2)의 시간 복잡도를 가짐
 -> if) 첫 번째 원소를 피벗으로 삼을 때, 이미 정렬된 배열에 대해서 퀵 정렬을 수행하면?
 -> 피벗 값 자기 자신에서 자기 자신의 위치로 변경이 이루어짐
 -> 분할이 이루어졌을 때 왼쪽은 분할이 이루어지지 않고, 오른쪽 데이터들만 남는 형태로 분할이 이루어짐
 -> 오른쪽 데이터들에 대해 또 퀵 정렬 수행(분할이 수행되는 횟수가 N번)
 -> 분할을 하기 위해 매번 선형탐색을 해야하므로 전체 시간 복잡도가 O(N^2)

4. 계수 정렬
 - 각 데이터가 몇 번씩 등장했는지 개수를 세는 방식으로 동작
 - 가장 작은 데이터부터 가장 큰 데이터 범위까지를 담을 수 있는 배열 크기를 만들어야 함 -> 공간 복잡도 높음
(1) 정의
 - 특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠르게 동작하는 정렬 알고리즘
 -> 계수 정렬을 데이터의 크기 범위가 제한되어, 정수 형태로 표현할 수 있을 때 사용 가능
 - 데이터의 개수가 N, 데이터(양수) 중 최댓값이 K 일 때 - 최악의 경우에도 수행 시간 O(N + K)를 보장

(2) 동작 원리
 1) [Step 0] 가장 작은 데이터부터 ~ 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트 초기화
  - 리스트의 각각의 인덱스가 각 데이터 값에 해당함
  -> 각각의 데이터가 몇 번씩 등장했는지 그 개수를 셈
  - 배열에서 특정 인덱스에 접근할 때 알고리즘 상으로, 상수 시간이 걸림
  -> 데이터를 하나씩 확인하며, 그 데이터와 동일한 인덱스에 count 값을 +1씩 증가
 2) [Step 1] 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터(계수 값)를 1씩 증가
 3) 결과적으로, 최종 리스트에는 각 데이터가 몇 번씩 등장했는지 그 횟수가 기록됨.
 4) 결과 확인할 때 - 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 반복하며 인덱스 출력

(3) 복잡도 분석
 - 계수 정렬의 시간 복잡도 & 공간 복잡도 = O(N + K)
 - 계수 정렬은 때에 따라 심각한 비효율성 초래 가능
  Ex) 데이터가 0과 999,999로 단 2개만 존재하는 경우는
 - 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용 가능
  Ex) 성적의 경우 100점을 맞는 학생이 여러 명일 수 있어 계수 정렬이 효과적

